#!/usr/bin/env ruby

require 'rubygems'
require 'pp'
require 'readline'
require 'optparse'
require 'pathname'
require 'set'
require 'shellwords'
require 'open3'
require 'base64'
require 'exiftool'
require 'fileutils'

def pp_tag values
	values_str = values.map { |v| v.to_s.length > 64 ? (v.to_s.slice(0, 64) + '...') : v }

	case values.length
	when 0 then '- (empty)'
	when 1 then values_str[0]
	else sprintf("(%d) [%s]", values.length, values_str.join(', '))
	end
end

def flac_block_picture(image, desc = '')
	begin
		image = File.expand_path(image)
		img = Exiftool.new(image)
		content = IO.binread(image)
	rescue
		raise ArgumentError, "\"#{image}\" cannot be read"
	end

	meta = img.results[0].to_hash
	mime = meta[:mime_type]

	raise(ArgumentError, "Unsupported image type. Use JPEG or PNG.") unless ['image/png', 'image/jpeg'].include?(mime)

	pack = [
		3, # Front cover
		mime.length,
		mime,
		desc.bytesize,
		desc,
		meta[:image_width],
		meta[:image_height],
		meta[:color_components] * meta[:bits_per_sample],
		0, # palette
		content.length,
		content
	].pack(sprintf("L>L>A%dL>a%dL>L>L>L>L>a*", mime.length, desc.bytesize))
	Base64.strict_encode64(pack)
end

class TagContainer
	def initialize(file)
		@hash = Hash.new 

		dump = `#{Shellwords.shelljoin ['vorbiscomment', '-l', file]}`
		dump.each_line do |l|
			tag, value = l.split('=', 2)
			self.add_tag(tag)
			@hash[tag.upcase].add(value.strip)
		end
	end

	def [](tag)
		self.has_tag?(tag) ? @hash[tag.upcase] : Set.new.freeze
	end

	def has_tag? tag
		@hash.has_key?(tag.upcase)
	end

	def add_tag tag
		@hash[tag.upcase] = Set.new unless self.has_tag?(tag)
	end

	def rm_tag tag
		@hash.delete tag.upcase
	end

	def set_values(tag, *values)
		self.add_tag tag
		@hash[tag.upcase].replace(values)
	end

	def add_values(tag, *values)
		self.add_tag tag
		@hash[tag.upcase].merge(values)
	end

	def rm_values(tag, *values)
		if values.empty? then @hash.delete(tag.upcase)
		else
			@hash[tag.upcase].subtract(values)
			@hash.delete(tag.upcase) if @hash[tag.upcase].empty?
		end
	end

	def tags
		@hash.keys
	end

	def each
		@hash.each { |k, v| yield(k, v) }
	end

	def to_s
		TagContainer.sorted_tags(@hash.keys).map do |tag|
			s.push pp_tag(@hash[tag])
		end.join "\n"
	end

	def vorbiscomment_dump
		dump = []

		TagContainer.sorted_tags(@hash.keys) do |tag|
			@hash[tag].to_a.sort.each { |v| dump << "#{tag}=#{v}" }
		end

		dump.join "\n"
	end

	def self.sorted_tags(tags)
		a = tags.sort
		a.delete('METADATA_BLOCK_PICTURE') and a.push('METADATA_BLOCK_PICTURE')
		block_given? ? a.each { |v| yield v } : a
	end
end

class OggAlbum
	attr_reader :path
	attr_reader :files
	attr_reader :selected_files

	include Enumerable

	def initialize path
		@path = Pathname.new File.expand_path(path)
		@files = {}

		Dir.glob("#{@path.to_s.gsub(/([\[\]\{\}\*\?\\])/, '\\\\\1')}/**/*.ogg") do |song|
			rel_path = Pathname.new(song).relative_path_from(@path)
			@files[rel_path] = TagContainer.new(song)
		end

		@selected_files = Set.new @files.keys
	end

	def tags_used
		s = Set.new
		@selected_files.each do |file|
			s.merge @files[file].tags
		end
		s.to_a.map { |v| v.downcase }
	end

	def summary(selected_tag = nil)
		data = Hash.new { |h, k| h[k] = Hash.new }

		positions = Hash[@files.keys.sort.each_with_index.to_a]

		@selected_files.each do |file|
			@files[file].each do |k, v|
				next unless selected_tag.nil? or k.eql?(selected_tag)
				data[k][positions[file]] = v.to_a.sort
			end
		end

		data
	end

	def write
		@files.each do |file, tags|
			command = "#{Shellwords.shelljoin ['vorbiscomment', '-w', File.join(@path, file)]}"
			o, s = Open3.capture2(command, :stdin_data => tags.vorbiscomment_dump())
		end
	end

	def set_tag(tag, *values)
		tag.upcase!
		tag = 'METADATA_BLOCK_PICTURE' if tag == 'PICTURE'
		if tag == 'METADATA_BLOCK_PICTURE'
			values = [ flac_block_picture(values[0], values.length == 2 ? values[1] : '') ]
		end
		@selected_files.each { |file| @files[file].set_values(tag, *values) }
	end

	def add_tag(tag, *values)
		tag.upcase!
		tag = 'METADATA_BLOCK_PICTURE' if tag == 'PICTURE'
		if tag == 'METADATA_BLOCK_PICTURE'
			values = [ flac_block_picture(values[0], values.length == 2 ? values[1] : '') ]
		end
		@selected_files.each { |file| @files[file].add_values(tag, *values) }
	end

	def rm_tag(tag, *values)
		tag.upcase!
		@selected_files.each do |file|
			@files[file].rm_values(tag, *values)
		end
	end

	def ls
		out = []
		@files.keys.sort.each_with_index do |file, i|
			out.push sprintf("%s %4d: %s", (@selected_files.include?(file) ? '*' : ' '), i+1, file)
		end
		out.join("\n")
	end

	def select(args)
		all_files = @files.keys.sort
		mode = :absolute

		first_rel = !!(args.first =~ /^[+-]/)

		sel = first_rel ? Set.new(@selected_files) : Set.new

		args.each do |selector|
			case selector
			when 'all'
				raise "Cannot use the \"#{selector}\" selector after a cumulative selector (+/-...)" if mode == :cumulative
				sel.replace all_files
			when /^([+-]?)([1-9]\d*)$/
				i = $2.to_i - 1
				raise "Item #{$2} is out of range" if i >= all_files.length

				items = [all_files.slice(i)]
				case $1
				when '-'
					sel.subtract items
					mode = :cumulative
				when '+'
					sel.merge items
					mode = :cumulative
				else
					raise "Cannot use the \"#{selector}\" selector after a cumulative selector (+/-...)" if mode == :cumulative
					sel.merge items
				end
			when /^([+-]?)(?:([1-9]\d*)-([1-9]\d*))$/
				i = $2.to_i - 1
				j = $3.to_i - 1
				raise "Range #{$2}-#{$3} is invalid" if i >= all_files.length or j >= all_files.length or i > j

				items = all_files.slice(i..j)
				case $1
				when '-'
					sel.subtract items
					mode = :cumulative
				when '+'
					sel.merge items
					mode = :cumulative
				else
					raise "Cannot use the \"#{selector}\" selector after a cumulative selector (+/-...)" if mode == :cumulative
					sel.merge items
				end
			end
		end

		@selected_files.replace sel
	end

	def auto_tracknumber
		@selected_files.sort.each_with_index do |file, i|
			@files[file].set_values('TRACKNUMBER', (i+1).to_s)
		end
	end

	def validate_tag(tag)
		values = @selected_files.map { |file| @files[file][tag] }
		values.reduce(true) { |r, v| r && yield(v) }
	end

	def tag_used_k_times?(tag, k)
		self.validate_tag(tag) { |v| v.size == k }
	end

	def tag_used_once?(tag)
		self.tag_used_k_times?(tag, 1)
	end

	def tag_unused?(tag)
		self.tag_used_k_times?(tag, 0)
	end

	def validate_tags(tags)
		tags.reduce(true) { |result, tag| result && yield(tag) }
	end

	def uniq_tag?(tag)
		values = @selected_files.map { |file| @files[file][tag] }
		values.reduce(true) { |r, v| r && (v.size == 1) } && (values.map { |v| v.first }.uniq.length == 1)
	end

	def numeric_tag?(tag)
		self.validate_tag(tag) { |v| v.first =~ /^[1-9][0-9]*$/ }
	end

	def check(type)
		uniq_tags = %w{ALBUM}
		uniq_tags << 'ALBUMARTIST' if type == 'album'

		common_tags = %w{ARTIST TRACKNUMBER TITLE DATE}

		required_tags = uniq_tags + common_tags

		unless self.validate_tags(uniq_tags) { |tag| self.uniq_tag?(tag) }
			puts "Each of the following tags must have a single and uniq value among all songs: #{uniq_tags.join ', '}."
			return false
		end

		unless self.validate_tags(common_tags) { |tag| self.tag_used_once?(tag) }
			puts "Each of the following tags must be used once per track: #{common_tags.join ', '}."
			return false
		end

		unless self.tag_unused?('DISCNUMBER') or self.tag_used_once?('DISCNUMBER')
			puts "The DISCNUMBER tag must be either unused or used once per track."
			return false
		end

		numeric_tags = %w{TRACKNUMBER}
		numeric_tags << 'DISCNUMBER' if self.tag_used_once?('DISCNUMBER')
		unless self.validate_tags(numeric_tags) { |tag| self.numeric_tag?(tag) }
			puts "The following tags must have numeric values: #{numeric_tags.join ', '}."
			return false
		end

		return true
	end

	def auto_rename(type)
		return unless self.check(type)

		tn_maxlength = $album.summary('TRACKNUMBER')['TRACKNUMBER'].values.map { |v| v.first }.max_by { |v| v.length }.length
		tn_format = '%0' + tn_maxlength.to_s + 'd'

		has_discnumber = self.tag_used_once?('DISCNUMBER')
		if has_discnumber
			dn_maxlength = $album.summary('DISCNUMBER')['DISCNUMBER'].values.map { |v| v.first }.max_by { |v| v.length }.length
			dn_format = '%0' + dn_maxlength.to_s + 'd'
		end

		format_number = lambda do |tags|
			s = ''
			if has_discnumber
				s += sprintf(dn_format, tags['DISCNUMBER'].first.to_i) + '.'
			end
			s += sprintf(tn_format, tags['TRACKNUMBER'].first.to_i)
		end

		case type
		when 'album'
			mapping = {}
			@selected_files.each do |file|
				tags = @files[file]
				mapping[file] = sprintf('%s - %s - %s - %s - %s.ogg',
					tags['ARTIST'].first, tags['DATE'].first, tags['ALBUM'].first,
					format_number.call(tags),
					tags['TITLE'].first)
			end

			dirname = sprintf('%s - %s - %s',
				$album.summary('ALBUMARTIST')['ALBUMARTIST'].first[1].first,
				$album.summary('DATE')['DATE'].first[1].first,
				$album.summary('ALBUM')['ALBUM'].first[1].first)
		when 'compilation'
			mapping = {}
			@selected_files.each do |file|
				tags = @files[file]
				mapping[file] = sprintf('%s - %s - %s - %s - %s.ogg',
					tags['ALBUM'].first, format_number.call(tags),
					tags['ARTIST'].first, tags['DATE'].first, tags['TITLE'].first)
			end

			dirname = sprintf('%s - %s',
				$album.summary('DATE')['DATE'].first[1].first,
				$album.summary('ALBUM')['ALBUM'].first[1].first)
		end

		if mapping.values.uniq.size != @selected_files.size
			puts "Generated filenames are not uniq."
			return
		end

		begin
			path = @path.dirname + dirname.gsub(/[\\\/:*?"<>|]/, '')
			if @path != path
				FileUtils.mv(@path, path)
				@path = path
			end
		rescue Exception => ex
			puts "Cannot rename #{@path} to #{path}."
			puts ex
		end

		Set.new(@selected_files).each do |file|
			begin
				oldpath = File.join(@path, file)
				newpath = File.join(@path, mapping[file].gsub(/[\\\/:*?"<>|]/, ''))

				if oldpath != newpath
					FileUtils.mv(oldpath, newpath)
					@files[mapping[file]] = @files.delete(file)
				end

				@selected_files.delete(file).add(mapping[file])
			rescue Exception => ex
				puts "Cannot rename #{File.join(@path, file)} to #{File.join(@path, mapping[file])}."
				puts ex
			end
		end
	end
end

option_parser = OptionParser.new do |opts|
	executable_name = File.basename($PROGRAM_NAME)
	opts.banner = "Interactively edit an ogg album
Usage: #{executable_name} <album directory>"
end.parse!

def autocomplete(input)
	context = Readline.line_buffer.slice(0, Readline.point - input.length)
	begin
		args = Shellwords.shellwords(context)

		# If there is no space after a quoted string, no autocompletion,
		# or we may end up with things like "something"somethingelse
		return [] if context.size > 0 and Readline.completer_quote_characters.include?(context[-1])
	rescue ArgumentError => ex
		# We are autocompleting a quoted string
		# The quote will be the last item in the context, so we dump it
		context.slice!(-1) if context.size > 0 and Readline.completer_quote_characters.include?(context[-1])
		begin
			args = Shellwords.shellwords(context)
		rescue ArgumentError => ex
			return []
		end
	end

	props = []

	if args.empty? then props = %w{ls select show set add rm auto write help exit quit}
	elsif %w{ls select help exit quit}.include?(args[0]) then props = []
	elsif args[0] == 'show'
		if args.size == 1
			props = %w{tag}
		elsif args.size == 2
			props = $album.tags_used
		end
	elsif %w{add set}.include? args[0]
		if args.size == 1
			props = $album.tags_used # TODO add picture
		elsif %w{METADATA_BLOCK_PICTURE PICTURE}.include? args[1].upcase
			if args.size == 2
				props = Readline::FILENAME_COMPLETION_PROC.call(input)
			end
		end
	elsif args[0] == 'rm'
		if args.size == 1
			props = $album.tags_used
		else
			tag = args[1].upcase
			if tag == 'METADATA_BLOCK_PICTURE'
				$stderr.puts
				$stderr.puts "Autocompletion is not supported for pictures"
				Readline.refresh_line
			else props = $album.summary(tag)[tag].values.flatten.uniq
			end
		end
	elsif args[0] == 'auto'
		if args.length == 1 then props = %w{tracknumber rename}
		elsif args.length == 2 and args[1] == 'rename' then props = %w{album compilation}
		end
	end

	(props || []).grep(/^#{Regexp.escape(input)}/).map do |v|
		v.include?(' ') ? "\"#{v}\"" : v
	end
end

def main(album_dir)
	$album = OggAlbum.new(album_dir)

	Readline.completion_append_character = " "
	#Readline.completer_word_break_characters = "\x00"
	Readline.completer_quote_characters = "\"'"
	Readline.completion_proc = ->(input) {
		autocomplete(input)
	}

	loop do
		command = Readline.readline("> ", true)
		break if command.nil? or command.eql?('exit') or command.eql?('quit')

		execute_command(command.strip)
	end
end

def print_album_summary(summary)
	TagContainer.sorted_tags(summary.keys) do |tag|
		puts tag

		if (summary[tag].size == $album.selected_files.size) && (summary[tag].values.uniq.length == 1)
			# If all tracks have only one common value
			puts "\t#{pp_tag(summary[tag].first[1])}"
		else
			summary[tag].keys.sort.each do |i|
				values = summary[tag][i]
				puts sprintf("\t%4d: %s", i+1, pp_tag(values))
			end
		end
	end
end

def show_command(command)
	case command.length
	when 0
		print_album_summary($album.summary)
	else
		case command[0]
		when 'tag'
			if command.size == 1 then puts 'You need to specify a tag name'
			else print_album_summary $album.summary(command[1].upcase)
			end
		else
			puts "Unknown command 'show #{command[0]}'"
		end
	end
end

def execute_command(command_line)
	begin
		command, *args = Shellwords.shellwords(command_line)
	rescue Exception => ex
		puts command line, "Invalid command"
		return
	end

	case command
	when 'ls' then puts $album.ls()
	when 'select'
		if args.length < 1
			puts 'You need to specify the files you want to select. Either enter "all", a single number or a range ("3-5").', 'Number and range based selections can be made cumulative by adding a plus or minus sign in front of the selector (ex. "-1-3")'
		else
			begin
				$album.select(args)
				puts $album.ls()
			rescue Exception => err
				puts err
			end
		end
	when 'show' then show_command(args)
	when 'set'
		if args.length < 2
			puts 'You need to specify the tag to edit and at least one value.'
		else
			$album.set_tag(*args)
		end
	when 'add'
		if args.length < 2
			puts 'You need to specify the tag to edit and at least one value.'
		else
			$album.add_tag(*args)
		end
	when 'rm'
		if args.length < 1
			puts 'You need to specify the tag to edit and eventually one or several values.'
		else
			$album.rm_tag(*args)
		end
	when 'auto'
		if args.length < 1
			puts 'You need to specify the auto command you want to execute.'
		else
			case args[0]
			when 'tracknumber' then $album.auto_tracknumber()
			when 'rename'
				if args.length < 2
					puts 'You need to specify if this is an album or a compilation.'
				elsif %w{album compilation}.include?(args[1])
					$album.auto_rename(args[1])
				else
					puts "Unknown album type \"#{args[1]}\"."
				end
			end
		end
	when 'write'
		$album.write
	when 'help'
	else
		puts "Unknown command \"#{command}\""
	end
end

album_dir = ARGV.shift
if album_dir && Dir.exists?(album_dir)
	main(album_dir)
else
	STDERR.puts "Error: This album does not exists."
	exit 1
end
